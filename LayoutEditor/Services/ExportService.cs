using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using LayoutEditor.Models;

namespace LayoutEditor.Services
{
    /// <summary>
    /// Export service for various formats (SVG, DXF, CSV/BOM)
    /// </summary>
    public class ExportService
    {
        #region SVG Export

        public string ExportToSvg(LayoutData layout, bool includeBackground = true)
        {
            var sb = new StringBuilder();
            var width = layout.Canvas.Width;
            var height = layout.Canvas.Height;

            sb.AppendLine($"<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            sb.AppendLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"{width}\" height=\"{height}\" viewBox=\"0 0 {width} {height}\">");
            sb.AppendLine($"  <title>{EscapeXml(layout.Metadata.Name)}</title>");
            sb.AppendLine($"  <desc>Generated by Layout Editor - {DateTime.Now:yyyy-MM-dd HH:mm}</desc>");

            // Background
            if (includeBackground)
            {
                sb.AppendLine($"  <rect width=\"{width}\" height=\"{height}\" fill=\"white\"/>");
            }

            // Grid layer
            sb.AppendLine("  <g id=\"grid\" opacity=\"0.3\">");
            for (int x = 0; x <= width; x += layout.Canvas.GridSize)
            {
                sb.AppendLine($"    <line x1=\"{x}\" y1=\"0\" x2=\"{x}\" y2=\"{height}\" stroke=\"#ddd\" stroke-width=\"0.5\"/>");
            }
            for (int y = 0; y <= height; y += layout.Canvas.GridSize)
            {
                sb.AppendLine($"    <line x1=\"0\" y1=\"{y}\" x2=\"{width}\" y2=\"{y}\" stroke=\"#ddd\" stroke-width=\"0.5\"/>");
            }
            sb.AppendLine("  </g>");

            // Walls layer
            if (layout.Walls.Count > 0)
            {
                sb.AppendLine("  <g id=\"walls\">");
                foreach (var wall in layout.Walls)
                {
                    var color = wall.Color ?? "#444444";
                    var dashArray = wall.WallType == WallTypes.Glass ? " stroke-dasharray=\"10,5\"" : "";
                    sb.AppendLine($"    <line x1=\"{wall.X1}\" y1=\"{wall.Y1}\" x2=\"{wall.X2}\" y2=\"{wall.Y2}\" stroke=\"{color}\" stroke-width=\"{wall.Thickness}\"{dashArray}/>");
                }
                sb.AppendLine("  </g>");
            }

            // Columns layer
            if (layout.Columns.Count > 0)
            {
                sb.AppendLine("  <g id=\"columns\">");
                foreach (var col in layout.Columns)
                {
                    if (col.Shape == "round")
                        sb.AppendLine($"    <circle cx=\"{col.X}\" cy=\"{col.Y}\" r=\"{col.Width / 2}\" fill=\"#666\" stroke=\"#444\" stroke-width=\"1\"/>");
                    else
                        sb.AppendLine($"    <rect x=\"{col.X - col.Width / 2}\" y=\"{col.Y - col.Height / 2}\" width=\"{col.Width}\" height=\"{col.Height}\" fill=\"#666\" stroke=\"#444\" stroke-width=\"1\"/>");
                }
                sb.AppendLine("  </g>");
            }

            // Zones layer
            if (layout.Zones.Count > 0)
            {
                sb.AppendLine("  <g id=\"zones\">");
                foreach (var zone in layout.Zones)
                {
                    var fill = zone.Type switch
                    {
                        "production" => "rgba(0,255,0,0.1)",
                        "storage" => "rgba(0,0,255,0.1)",
                        "safety" => "rgba(255,255,0,0.2)",
                        _ => "rgba(128,128,128,0.1)"
                    };
                    sb.AppendLine($"    <rect x=\"{zone.X}\" y=\"{zone.Y}\" width=\"{zone.Width}\" height=\"{zone.Height}\" fill=\"{fill}\" stroke=\"#888\" stroke-width=\"1\" stroke-dasharray=\"5,5\"/>");
                    sb.AppendLine($"    <text x=\"{zone.X + 5}\" y=\"{zone.Y + 15}\" font-size=\"12\" fill=\"#666\">{EscapeXml(zone.Name)}</text>");
                }
                sb.AppendLine("  </g>");
            }

            // Paths layer
            if (layout.Paths.Count > 0)
            {
                sb.AppendLine("  <g id=\"paths\">");
                foreach (var path in layout.Paths)
                {
                    var fromNode = layout.Nodes.FirstOrDefault(n => n.Id == path.From);
                    var toNode = layout.Nodes.FirstOrDefault(n => n.Id == path.To);
                    if (fromNode == null || toNode == null) continue;

                    var x1 = fromNode.Visual.X + fromNode.Visual.Width / 2;
                    var y1 = fromNode.Visual.Y + fromNode.Visual.Height / 2;
                    var x2 = toNode.Visual.X + toNode.Visual.Width / 2;
                    var y2 = toNode.Visual.Y + toNode.Visual.Height / 2;

                    sb.AppendLine($"    <line x1=\"{x1}\" y1=\"{y1}\" x2=\"{x2}\" y2=\"{y2}\" stroke=\"#666\" stroke-width=\"1.5\" marker-end=\"url(#arrow)\"/>");
                }
                sb.AppendLine("  </g>");
            }

            // Nodes layer
            sb.AppendLine("  <g id=\"nodes\">");
            foreach (var node in layout.Nodes)
            {
                var x = node.Visual.X;
                var y = node.Visual.Y;
                var w = node.Visual.Width;
                var h = node.Visual.Height;
                var color = node.Visual.Color ?? "#4A90D9";

                sb.AppendLine($"    <rect x=\"{x}\" y=\"{y}\" width=\"{w}\" height=\"{h}\" fill=\"{color}\" stroke=\"#333\" stroke-width=\"1\" rx=\"4\"/>");
                sb.AppendLine($"    <text x=\"{x + w / 2}\" y=\"{y + h + 14}\" font-size=\"10\" text-anchor=\"middle\" fill=\"#333\">{EscapeXml(node.Name)}</text>");
            }
            sb.AppendLine("  </g>");

            // Groups/Cells layer
            if (layout.Groups.Count > 0)
            {
                sb.AppendLine("  <g id=\"cells\">");
                foreach (var group in layout.Groups.Where(g => g.IsCell))
                {
                    var bounds = GetGroupBounds(layout, group);
                    if (bounds == null) continue;
                    var (minX, minY, maxX, maxY) = bounds.Value;
                    sb.AppendLine($"    <rect x=\"{minX}\" y=\"{minY}\" width=\"{maxX - minX}\" height=\"{maxY - minY}\" fill=\"none\" stroke=\"orange\" stroke-width=\"2\" stroke-dasharray=\"6,3\" rx=\"8\"/>");
                    sb.AppendLine($"    <text x=\"{minX + 5}\" y=\"{minY - 5}\" font-size=\"11\" fill=\"orange\">‚óè {EscapeXml(group.Name)}</text>");
                }
                sb.AppendLine("  </g>");
            }

            // Measurements layer
            if (layout.Measurements.Count > 0)
            {
                sb.AppendLine("  <g id=\"measurements\">");
                foreach (var m in layout.Measurements)
                {
                    var length = Math.Sqrt((m.X2 - m.X1) * (m.X2 - m.X1) + (m.Y2 - m.Y1) * (m.Y2 - m.Y1));
                    var label = m.ShowLength ? $"{length / layout.Metadata.PixelsPerUnit:F2} {layout.Metadata.Units}" : m.Label;
                    var midX = (m.X1 + m.X2) / 2;
                    var midY = (m.Y1 + m.Y2) / 2;

                    sb.AppendLine($"    <line x1=\"{m.X1}\" y1=\"{m.Y1}\" x2=\"{m.X2}\" y2=\"{m.Y2}\" stroke=\"#c00\" stroke-width=\"1\"/>");
                    sb.AppendLine($"    <text x=\"{midX}\" y=\"{midY - 5}\" font-size=\"10\" fill=\"#c00\">{EscapeXml(label)}</text>");
                }
                sb.AppendLine("  </g>");
            }

            // Arrow marker definition
            sb.AppendLine("  <defs>");
            sb.AppendLine("    <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\">");
            sb.AppendLine("      <path d=\"M0,0 L0,6 L9,3 z\" fill=\"#666\"/>");
            sb.AppendLine("    </marker>");
            sb.AppendLine("  </defs>");

            sb.AppendLine("</svg>");
            return sb.ToString();
        }

        #endregion

        #region DXF Export

        public string ExportToDxf(LayoutData layout)
        {
            var sb = new StringBuilder();
            var scale = layout.Metadata.PixelsPerUnit;

            // DXF Header
            sb.AppendLine("0");
            sb.AppendLine("SECTION");
            sb.AppendLine("2");
            sb.AppendLine("HEADER");
            sb.AppendLine("9");
            sb.AppendLine("$ACADVER");
            sb.AppendLine("1");
            sb.AppendLine("AC1014"); // AutoCAD R14 format
            sb.AppendLine("0");
            sb.AppendLine("ENDSEC");

            // Tables section (layers)
            sb.AppendLine("0");
            sb.AppendLine("SECTION");
            sb.AppendLine("2");
            sb.AppendLine("TABLES");
            
            // Layer table
            sb.AppendLine("0");
            sb.AppendLine("TABLE");
            sb.AppendLine("2");
            sb.AppendLine("LAYER");

            // Define layers
            AddDxfLayer(sb, "WALLS", 8);      // Gray
            AddDxfLayer(sb, "NODES", 5);      // Blue
            AddDxfLayer(sb, "PATHS", 3);      // Green
            AddDxfLayer(sb, "ZONES", 4);      // Cyan
            AddDxfLayer(sb, "CELLS", 30);     // Orange
            AddDxfLayer(sb, "MEASUREMENTS", 1); // Red
            AddDxfLayer(sb, "COLUMNS", 8);    // Gray

            sb.AppendLine("0");
            sb.AppendLine("ENDTAB");
            sb.AppendLine("0");
            sb.AppendLine("ENDSEC");

            // Entities section
            sb.AppendLine("0");
            sb.AppendLine("SECTION");
            sb.AppendLine("2");
            sb.AppendLine("ENTITIES");

            // Export walls
            foreach (var wall in layout.Walls)
            {
                AddDxfLine(sb, "WALLS", 
                    wall.X1 / scale, -wall.Y1 / scale, 
                    wall.X2 / scale, -wall.Y2 / scale);
            }

            // Export columns
            foreach (var col in layout.Columns)
            {
                if (col.Shape == "round")
                {
                    AddDxfCircle(sb, "COLUMNS", col.X / scale, -col.Y / scale, col.Width / 2 / scale);
                }
                else
                {
                    // Rectangle as 4 lines
                    var x1 = (col.X - col.Width / 2) / scale;
                    var y1 = -(col.Y - col.Height / 2) / scale;
                    var x2 = (col.X + col.Width / 2) / scale;
                    var y2 = -(col.Y + col.Height / 2) / scale;
                    AddDxfLine(sb, "COLUMNS", x1, y1, x2, y1);
                    AddDxfLine(sb, "COLUMNS", x2, y1, x2, y2);
                    AddDxfLine(sb, "COLUMNS", x2, y2, x1, y2);
                    AddDxfLine(sb, "COLUMNS", x1, y2, x1, y1);
                }
            }

            // Export zones
            foreach (var zone in layout.Zones)
            {
                var x1 = zone.X / scale;
                var y1 = -zone.Y / scale;
                var x2 = (zone.X + zone.Width) / scale;
                var y2 = -(zone.Y + zone.Height) / scale;
                AddDxfLine(sb, "ZONES", x1, y1, x2, y1);
                AddDxfLine(sb, "ZONES", x2, y1, x2, y2);
                AddDxfLine(sb, "ZONES", x2, y2, x1, y2);
                AddDxfLine(sb, "ZONES", x1, y2, x1, y1);
                AddDxfText(sb, "ZONES", x1, y1 + 0.5, zone.Name, 0.3);
            }

            // Export nodes as rectangles with labels
            foreach (var node in layout.Nodes)
            {
                var x1 = node.Visual.X / scale;
                var y1 = -node.Visual.Y / scale;
                var x2 = (node.Visual.X + node.Visual.Width) / scale;
                var y2 = -(node.Visual.Y + node.Visual.Height) / scale;
                
                AddDxfLine(sb, "NODES", x1, y1, x2, y1);
                AddDxfLine(sb, "NODES", x2, y1, x2, y2);
                AddDxfLine(sb, "NODES", x2, y2, x1, y2);
                AddDxfLine(sb, "NODES", x1, y2, x1, y1);
                AddDxfText(sb, "NODES", x1, y2 - 0.5, node.Name, 0.25);
            }

            // Export paths
            foreach (var path in layout.Paths)
            {
                var fromNode = layout.Nodes.FirstOrDefault(n => n.Id == path.From);
                var toNode = layout.Nodes.FirstOrDefault(n => n.Id == path.To);
                if (fromNode == null || toNode == null) continue;

                var x1 = (fromNode.Visual.X + fromNode.Visual.Width / 2) / scale;
                var y1 = -(fromNode.Visual.Y + fromNode.Visual.Height / 2) / scale;
                var x2 = (toNode.Visual.X + toNode.Visual.Width / 2) / scale;
                var y2 = -(toNode.Visual.Y + toNode.Visual.Height / 2) / scale;
                AddDxfLine(sb, "PATHS", x1, y1, x2, y2);
            }

            // Export measurements
            foreach (var m in layout.Measurements)
            {
                AddDxfLine(sb, "MEASUREMENTS", m.X1 / scale, -m.Y1 / scale, m.X2 / scale, -m.Y2 / scale);
                if (m.ShowLength)
                {
                    var length = Math.Sqrt((m.X2 - m.X1) * (m.X2 - m.X1) + (m.Y2 - m.Y1) * (m.Y2 - m.Y1)) / scale;
                    var label = $"{length:F2}";
                    AddDxfText(sb, "MEASUREMENTS", (m.X1 + m.X2) / 2 / scale, -(m.Y1 + m.Y2) / 2 / scale, label, 0.2);
                }
            }

            sb.AppendLine("0");
            sb.AppendLine("ENDSEC");
            sb.AppendLine("0");
            sb.AppendLine("EOF");

            return sb.ToString();
        }

        private void AddDxfLayer(StringBuilder sb, string name, int color)
        {
            sb.AppendLine("0");
            sb.AppendLine("LAYER");
            sb.AppendLine("2");
            sb.AppendLine(name);
            sb.AppendLine("70");
            sb.AppendLine("0");
            sb.AppendLine("62");
            sb.AppendLine(color.ToString());
            sb.AppendLine("6");
            sb.AppendLine("CONTINUOUS");
        }

        private void AddDxfLine(StringBuilder sb, string layer, double x1, double y1, double x2, double y2)
        {
            sb.AppendLine("0");
            sb.AppendLine("LINE");
            sb.AppendLine("8");
            sb.AppendLine(layer);
            sb.AppendLine("10");
            sb.AppendLine(x1.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("20");
            sb.AppendLine(y1.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("11");
            sb.AppendLine(x2.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("21");
            sb.AppendLine(y2.ToString("F4", CultureInfo.InvariantCulture));
        }

        private void AddDxfCircle(StringBuilder sb, string layer, double cx, double cy, double radius)
        {
            sb.AppendLine("0");
            sb.AppendLine("CIRCLE");
            sb.AppendLine("8");
            sb.AppendLine(layer);
            sb.AppendLine("10");
            sb.AppendLine(cx.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("20");
            sb.AppendLine(cy.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("40");
            sb.AppendLine(radius.ToString("F4", CultureInfo.InvariantCulture));
        }

        private void AddDxfText(StringBuilder sb, string layer, double x, double y, string text, double height)
        {
            sb.AppendLine("0");
            sb.AppendLine("TEXT");
            sb.AppendLine("8");
            sb.AppendLine(layer);
            sb.AppendLine("10");
            sb.AppendLine(x.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("20");
            sb.AppendLine(y.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("40");
            sb.AppendLine(height.ToString("F4", CultureInfo.InvariantCulture));
            sb.AppendLine("1");
            sb.AppendLine(text);
        }

        #endregion

        #region Bill of Materials Export

        public string ExportBomToCsv(LayoutData layout)
        {
            var sb = new StringBuilder();
            
            // Header
            sb.AppendLine("Type,Name,ID,X,Y,Width,Height,Cell,Processing Time,Capacity,Notes");

            // Group nodes by type
            var nodesByType = layout.Nodes.GroupBy(n => n.Type).OrderBy(g => g.Key);

            foreach (var group in nodesByType)
            {
                foreach (var node in group.OrderBy(n => n.Name))
                {
                    var cell = layout.Groups.FirstOrDefault(g => g.IsCell && g.Members.Contains(node.Id));
                    var cellName = cell?.Name ?? "";
                    
                    var x = node.Visual.X / layout.Metadata.PixelsPerUnit;
                    var y = node.Visual.Y / layout.Metadata.PixelsPerUnit;
                    var w = node.Visual.Width / layout.Metadata.PixelsPerUnit;
                    var h = node.Visual.Height / layout.Metadata.PixelsPerUnit;

                    sb.AppendLine($"{node.Type},{EscapeCsv(node.Name)},{node.Id},{x:F2},{y:F2},{w:F2},{h:F2},{EscapeCsv(cellName)},{node.Simulation?.ProcessTime?.Value ?? 0},{node.Simulation?.Capacity ?? 1},");
                }
            }

            return sb.ToString();
        }

        public string ExportEquipmentList(LayoutData layout)
        {
            var sb = new StringBuilder();
            sb.AppendLine("EQUIPMENT BILL OF MATERIALS");
            sb.AppendLine($"Layout: {layout.Metadata.Name}");
            sb.AppendLine($"Generated: {DateTime.Now:yyyy-MM-dd HH:mm}");
            sb.AppendLine($"Units: {layout.Metadata.Units}");
            sb.AppendLine();
            sb.AppendLine("=" + new string('=', 80));
            sb.AppendLine();

            // Summary by type
            sb.AppendLine("SUMMARY BY TYPE:");
            sb.AppendLine("-" + new string('-', 40));
            var typeCounts = layout.Nodes.GroupBy(n => n.Type)
                .Select(g => new { Type = g.Key, Count = g.Count() })
                .OrderByDescending(x => x.Count);

            foreach (var tc in typeCounts)
            {
                sb.AppendLine($"  {tc.Type,-20} {tc.Count,5}");
            }
            sb.AppendLine($"  {"TOTAL",-20} {layout.Nodes.Count,5}");
            sb.AppendLine();

            // Summary by cell
            if (layout.Groups.Any(g => g.IsCell))
            {
                sb.AppendLine("SUMMARY BY CELL:");
                sb.AppendLine("-" + new string('-', 40));
                foreach (var cell in layout.Groups.Where(g => g.IsCell).OrderBy(g => g.Name))
                {
                    sb.AppendLine($"  {cell.Name}: {cell.Members.Count} items");
                    var memberTypes = cell.Members
                        .Select(m => layout.Nodes.FirstOrDefault(n => n.Id == m))
                        .Where(n => n != null)
                        .GroupBy(n => n!.Type);
                    foreach (var mt in memberTypes)
                    {
                        sb.AppendLine($"    - {mt.Key}: {mt.Count()}");
                    }
                }
                sb.AppendLine();
            }

            // Detailed list
            sb.AppendLine("DETAILED EQUIPMENT LIST:");
            sb.AppendLine("-" + new string('-', 80));
            sb.AppendLine($"{"Name",-25} {"Type",-15} {"Cell",-15} {"X",8} {"Y",8} {"Process",8}");
            sb.AppendLine("-" + new string('-', 80));

            foreach (var node in layout.Nodes.OrderBy(n => n.Type).ThenBy(n => n.Name))
            {
                var cell = layout.Groups.FirstOrDefault(g => g.IsCell && g.Members.Contains(node.Id));
                var cellName = cell?.Name ?? "-";
                var x = node.Visual.X / layout.Metadata.PixelsPerUnit;
                var y = node.Visual.Y / layout.Metadata.PixelsPerUnit;
                var process = node.Simulation?.ProcessTime?.Value ?? 0;

                sb.AppendLine($"{node.Name,-25} {node.Type,-15} {cellName,-15} {x,8:F1} {y,8:F1} {process,8:F1}");
            }

            sb.AppendLine();
            sb.AppendLine("=" + new string('=', 80));
            sb.AppendLine($"Total Equipment: {layout.Nodes.Count}");
            sb.AppendLine($"Total Cells: {layout.Groups.Count(g => g.IsCell)}");
            sb.AppendLine($"Total Paths: {layout.Paths.Count}");

            return sb.ToString();
        }

        #endregion

        #region Helpers

        private string EscapeXml(string text)
        {
            return text
                .Replace("&", "&amp;")
                .Replace("<", "&lt;")
                .Replace(">", "&gt;")
                .Replace("\"", "&quot;");
        }

        private string EscapeCsv(string text)
        {
            if (text.Contains(",") || text.Contains("\"") || text.Contains("\n"))
            {
                return $"\"{text.Replace("\"", "\"\"")}\"";
            }
            return text;
        }

        private (double minX, double minY, double maxX, double maxY)? GetGroupBounds(LayoutData layout, GroupData group)
        {
            var members = group.Members
                .Select(m => layout.Nodes.FirstOrDefault(n => n.Id == m))
                .Where(n => n != null)
                .ToList();

            if (members.Count == 0) return null;

            var padding = 15.0;
            var minX = members.Min(n => n!.Visual.X) - padding;
            var minY = members.Min(n => n!.Visual.Y) - padding;
            var maxX = members.Max(n => n!.Visual.X + n!.Visual.Width) + padding;
            var maxY = members.Max(n => n!.Visual.Y + n!.Visual.Height) + padding;

            return (minX, minY, maxX, maxY);
        }

        #endregion
    }
}
